name: CI with Testing, Benchmarks, Coverage, Static Analysis, Formatting, and Documentation

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: write # Needed for GitHub Pages deployment
  pull-requests: write
  issues: write

jobs:
  # Code formatting check
  format-check:
    name: Code Formatting Check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install clang-format
        run: |
          sudo apt-get update
          sudo apt-get install -y clang-format

      - name: Check formatting
        run: |
          chmod +x ./scripts/check-format.sh
          ./scripts/check-format.sh

      - name: Comment on PR if formatting needed
        if: failure() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const body = `## üé® Code Formatting Check Failed

            Some files are not properly formatted according to the project's clang-format rules.

            **To fix locally:**
            \`\`\`bash
            ./scripts/format-code.sh
            git add .
            git commit -m "Format code with clang-format"
            git push
            \`\`\`

            Or format individual files:
            \`\`\`bash
            clang-format -i src/your_file.cpp
            \`\`\``;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  # Main build and test job
  build-test-benchmark:
    name: ${{ matrix.os }} - ${{ matrix.compiler }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        compiler: [gcc, clang]
        exclude:
          - os: windows-latest
            compiler: gcc
          - os: windows-latest
            compiler: clang
        include:
          - os: windows-latest
            compiler: msvc

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install ccache (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y ccache

      - name: Install ccache (macOS)
        if: runner.os == 'macOS'
        run: brew install ccache

      - name: Setup ccache
        if: runner.os != 'Windows'
        uses: hendrikmuhs/ccache-action@v1.2
        with:
          key: ${{ runner.os }}-${{ matrix.compiler }}-bench
          max-size: 500M

      - name: Cache CMake dependencies
        uses: actions/cache@v4
        with:
          path: |
            build/_deps
          key: ${{ runner.os }}-cmake-deps-${{ hashFiles('**/CMakeLists.txt') }}
          restore-keys: |
            ${{ runner.os }}-cmake-deps-

      - name: Set up compiler (Linux)
        if: runner.os == 'Linux'
        run: |
          if [ "${{ matrix.compiler }}" = "gcc" ]; then
            echo "CC=gcc" >> $GITHUB_ENV
            echo "CXX=g++" >> $GITHUB_ENV
          else
            echo "CC=clang" >> $GITHUB_ENV
            echo "CXX=clang++" >> $GITHUB_ENV
          fi
          echo "CMAKE_CXX_COMPILER_LAUNCHER=ccache" >> $GITHUB_ENV
          echo "CMAKE_C_COMPILER_LAUNCHER=ccache" >> $GITHUB_ENV

      - name: Set up compiler (macOS)
        if: runner.os == 'macOS'
        run: |
          if [ "${{ matrix.compiler }}" = "gcc" ]; then
            brew install gcc
            echo "CC=gcc-13" >> $GITHUB_ENV
            echo "CXX=g++-13" >> $GITHUB_ENV
          else
            echo "CC=clang" >> $GITHUB_ENV
            echo "CXX=clang++" >> $GITHUB_ENV
          fi
          echo "CMAKE_CXX_COMPILER_LAUNCHER=ccache" >> $GITHUB_ENV
          echo "CMAKE_C_COMPILER_LAUNCHER=ccache" >> $GITHUB_ENV

      - name: Configure CMake
        run: cmake -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_BENCHMARKS=ON

      - name: Build
        run: cmake --build build --config Release

      - name: Run tests
        run: ctest --test-dir build --build-config Release --output-on-failure --verbose

      - name: Run benchmarks
        if: runner.os == 'Linux' && matrix.compiler == 'gcc'
        run: |
          ./build/bin/mathlib_benchmarks \
            --benchmark_format=json \
            --benchmark_out=benchmark_results.json \
            --benchmark_repetitions=3 \
            --benchmark_report_aggregates_only=true

      - name: Upload benchmark results
        if: runner.os == 'Linux' && matrix.compiler == 'gcc'
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results-${{ github.sha }}
          path: benchmark_results.json

      - name: Store baseline (main branch only)
        if: runner.os == 'Linux' && matrix.compiler == 'gcc' && github.ref == 'refs/heads/main'
        run: |
          mkdir -p benchmark_baselines
          cp benchmark_results.json benchmark_baselines/baseline_main.json

      - name: Upload baseline
        if: runner.os == 'Linux' && matrix.compiler == 'gcc' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-baseline
          path: benchmark_baselines/baseline_main.json

      - name: ccache statistics
        if: runner.os != 'Windows'
        run: ccache -s

  # Static analysis with clang-tidy
  clang-tidy:
    name: Clang-Tidy Analysis
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install clang-tidy
        run: |
          sudo apt-get update
          sudo apt-get install -y clang-tidy

      - name: Configure CMake
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE=Debug \
            -DENABLE_CLANG_TIDY=ON \
            -DBUILD_BENCHMARKS=OFF
        env:
          CC: clang
          CXX: clang++

      - name: Run clang-tidy
        run: |
          cmake --build build 2>&1 | tee clang-tidy-report.txt || true

      - name: Check for clang-tidy warnings
        run: |
          if grep -q "warning:" clang-tidy-report.txt; then
            echo "‚ö†Ô∏è Clang-tidy found warnings:"
            grep "warning:" clang-tidy-report.txt | head -20
            echo ""
            echo "See full report in artifacts"
          else
            echo "‚úÖ No clang-tidy warnings found!"
          fi

      - name: Upload clang-tidy report
        uses: actions/upload-artifact@v4
        with:
          name: clang-tidy-report
          path: clang-tidy-report.txt

  # Static analysis with cppcheck
  cppcheck:
    name: Cppcheck Analysis
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install cppcheck
        run: |
          sudo apt-get update
          sudo apt-get install -y cppcheck

      - name: Run cppcheck
        run: |
          cppcheck --version
          cppcheck \
            --enable=all \
            --inconclusive \
            --force \
            --inline-suppr \
            --suppressions-list=.cppcheck-suppressions \
            --xml \
            --xml-version=2 \
            --output-file=cppcheck-report.xml \
            src/ 2>&1 | tee cppcheck-report.txt || true

      - name: Display cppcheck summary
        run: |
          echo "Cppcheck Summary:"
          if [ -s cppcheck-report.txt ]; then
            cat cppcheck-report.txt
          else
            echo "‚úÖ No issues found by cppcheck!"
          fi

      - name: Upload cppcheck reports
        uses: actions/upload-artifact@v4
        with:
          name: cppcheck-report
          path: |
            cppcheck-report.txt
            cppcheck-report.xml

  # Build with sanitizers
  sanitizers:
    name: Sanitizers (ASan + UBSan)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure CMake with sanitizers
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE=Debug \
            -DENABLE_SANITIZERS=ON \
            -DBUILD_BENCHMARKS=OFF
        env:
          CC: clang
          CXX: clang++

      - name: Build with sanitizers
        run: cmake --build build

      - name: Run tests with sanitizers
        run: |
          export ASAN_OPTIONS=detect_leaks=1:check_initialization_order=1:strict_init_order=1
          export UBSAN_OPTIONS=print_stacktrace=1:halt_on_error=1
          ctest --test-dir build --output-on-failure --verbose

      - name: Check for sanitizer issues
        run: |
          echo "‚úÖ Tests passed with sanitizers!"
          echo "No memory errors or undefined behavior detected."

  # Code coverage
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcovr lcov

      - name: Configure CMake with coverage
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE=Debug \
            -DENABLE_COVERAGE=ON \
            -DBUILD_BENCHMARKS=OFF
        env:
          CC: gcc
          CXX: g++

      - name: Build with coverage
        run: cmake --build build

      - name: Run tests
        run: ctest --test-dir build --output-on-failure

      - name: Generate coverage report (lcov)
        run: |
          lcov --capture \
            --directory build \
            --output-file coverage.info \
            --ignore-errors inconsistent,mismatch,gcov \
            --rc lcov_branch_coverage=1

          lcov --remove coverage.info \
            '/usr/*' \
            '*/tests/*' \
            '*/test_*.cpp' \
            '*/build/_deps/*' \
            --output-file coverage_filtered.info \
            --ignore-errors unused \
            --rc lcov_branch_coverage=1

          genhtml coverage_filtered.info \
            --output-directory coverage_html \
            --branch-coverage \
            --title "MathLib Coverage Report"

          echo "Coverage Summary:"
          lcov --summary coverage_filtered.info --rc lcov_branch_coverage=1

      - name: Generate coverage report (XML)
        run: |
          gcovr --xml-pretty \
            --exclude-unreachable-branches \
            --print-summary \
            --exclude 'tests/.*' \
            --exclude 'build/_deps/.*' \
            --output coverage.xml \
            build

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          verbose: true

      - name: Upload coverage HTML report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage_html/

      - name: Coverage comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            let coveragePercent = 'N/A';
            try {
              const coverageXml = fs.readFileSync('coverage.xml', 'utf8');
              const match = coverageXml.match(/line-rate="([0-9.]+)"/);
              if (match) {
                coveragePercent = (parseFloat(match[1]) * 100).toFixed(2) + '%';
              }
            } catch (err) {
              console.log('Could not read coverage data:', err);
            }

            const body = `## üìä Code Coverage Report

            **Coverage:** ${coveragePercent}

            View detailed coverage report in the workflow artifacts.

            Coverage data has been uploaded to Codecov for detailed analysis.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  # Generate and deploy documentation
  documentation:
    name: Generate Documentation
    runs-on: ubuntu-latest
    # Only run on pushes to main (not on PRs)
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Doxygen and Graphviz
        run: |
          sudo apt-get update
          sudo apt-get install -y doxygen graphviz

      - name: Generate documentation
        run: |
          echo "Generating documentation with Doxygen..."
          doxygen Doxyfile
          echo "Documentation generated successfully!"

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs/html
          publish_branch: gh-pages
          force_orphan: true
          user_name: "github-actions[bot]"
          user_email: "github-actions[bot]@users.noreply.github.com"
          commit_message: "Deploy documentation - ${{ github.event.head_commit.message }}"

  # Compare benchmarks on pull requests
  compare-benchmarks:
    name: Compare Performance
    runs-on: ubuntu-latest
    needs: build-test-benchmark
    if: github.event_name == 'pull_request'

    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Download current benchmark results
        uses: actions/download-artifact@v4
        with:
          name: benchmark-results-${{ github.sha }}
          path: ./current

      - name: Download baseline from main
        uses: dawidd6/action-download-artifact@v3
        with:
          workflow: ci.yml
          branch: main
          name: benchmark-baseline
          path: ./baseline
        continue-on-error: true

      - name: Compare benchmarks
        if: hashFiles('./baseline/baseline_main.json') != ''
        run: |
          python3 scripts/compare_benchmarks.py \
            ./baseline/baseline_main.json \
            ./current/benchmark_results.json \
            --threshold 1.20 \
            --warning-threshold 1.10 \
            > comparison_report.txt 2>&1 || true

      - name: Comment PR with benchmark results
        if: hashFiles('./baseline/baseline_main.json') != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            let report = '';
            try {
              report = fs.readFileSync('comparison_report.txt', 'utf8');
            } catch (err) {
              report = 'Error reading comparison report: ' + err.message;
            }

            const maxLength = 65000;
            if (report.length > maxLength) {
              report = report.substring(0, maxLength) + '\n\n... (truncated)';
            }

            const body = '## üìä Performance Benchmark Results\n\n```\n' + report + '\n```';

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Comment PR - no baseline
        if: hashFiles('./baseline/baseline_main.json') == ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const body = `## üìä Performance Benchmark Results

            ‚ÑπÔ∏è **No baseline found** - this is likely the first benchmark run.

            Current benchmark results will be saved as baseline when this PR is merged to main.
            Subsequent PRs will show performance comparisons against this baseline.

            ‚úÖ Benchmarks ran successfully and will establish the baseline.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  # Build with vcpkg to demonstrate dependency management
  build-with-vcpkg:
    name: Build with vcpkg - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Setup vcpkg
      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11

      # Configure with vcpkg (Unix)
      - name: Configure CMake (Unix)
        if: runner.os != 'Windows'
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake \
            -DUSE_VCPKG_DEPENDENCIES=ON \
            -DBUILD_BENCHMARKS=ON

      # Configure with vcpkg (Windows - all on one line for PowerShell)
      - name: Configure CMake (Windows)
        if: runner.os == 'Windows'
        run: cmake -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE="${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake" -DUSE_VCPKG_DEPENDENCIES=ON -DBUILD_BENCHMARKS=ON

      # Build
      - name: Build
        run: cmake --build build --config Release

      # Run tests
      - name: Run tests
        run: ctest --test-dir build --build-config Release --output-on-failure

      # Run example
      - name: Run example (Unix)
        if: runner.os != 'Windows'
        run: ./build/mathlib_example

      - name: Run example (Windows)
        if: runner.os == 'Windows'
        run: .\build\Release\mathlib_example.exe
